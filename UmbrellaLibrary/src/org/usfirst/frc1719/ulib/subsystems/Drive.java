// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1719.ulib.subsystems;

import java.util.Date;

import org.usfirst.frc1719.ulib.interfaces.ITestable;

import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Drive extends Subsystem implements ITestable {
	
	private static final int COOLDOWN_TIME = 1000;
	private Date lastRot = new java.util.Date(0L);
	private RobotDrive robotDrive;
	private static final int TEST_DUR = 100;
	private static final double TEST_SPEED = 0.5D;
	private boolean isPIDEnabled = true;
	private double[] pastErr = new double[0];
	private int interationNumber;
	private Gyro gyro;
	private Class<? extends Command> _default;
	
	/**
	 * 
	 * @param par1 the left front motor.
	 * @param par2 the left rear motor.
	 * @param par3 the right front motor.
	 * @param par4 the right rear motor.
	 * @param par5 the gyro to use for PID.
	 * @param par6 the default command to use.
	 */
	public Drive(SpeedController par1, SpeedController par2, SpeedController par3, SpeedController par4, Gyro par5, Class<? extends Command> par6) {
	    robotDrive = new RobotDrive(par1, par2, par3, par4);
        
        robotDrive.setSafetyEnabled(true);
        robotDrive.setExpiration(0.1);
        robotDrive.setSensitivity(0.5);
        robotDrive.setMaxOutput(1.0);
        robotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        
        gyro = par5;
        
        _default = par6;
	}
	
	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	/**
	 * @deprecated
	 * Moves the mechanum drive in a given way.
	 * 
	 * @param magnitude
	 *            a double on the interval [-1.0,1.0]. Defines the speed at
	 *            which the robot should move.
	 * @param direction
	 *            the radian measure of angle between the direction of the
	 *            strafe and the 'forward' of the robot.
	 * @param rotation
	 *            a double on the interval [-1.0,1.0]. Defines the speed at
	 *            which the robot should turn in place.
	 */
	@Deprecated
	public void moveMechanum(double magnitude, double direction, double rotation) {
		// converts from degrees to radians then executes mecanumdrivepolar
		robotDrive.mecanumDrive_Polar(magnitude, direction * 180 / Math.PI,
				rotation);
	}

	public void moveCartesian(double x, double y, double rot, boolean usePID) {
		// get PID constants
		double KP = SmartDashboard.getNumber("KP") * 0.001D;
		double KI = SmartDashboard.getNumber("KI") * 0.001D;
		double KD = SmartDashboard.getNumber("KD") * 0.001D;

		// Try to go straight if desired using PID
    	if(isPIDEnabled) {
    		
    		
    		
    		if(!usePID || (rot != 0.0D) || ((y == 0.0D) && (x == 0.0D))) isPIDEnabled = false;
    		else {
    			double err = gyro.getAngle();
    			double ierr = 0.0D;
    			for(int i = 0; i < pastErr.length; i++) {
    				ierr += pastErr[i];
    			}
    			double derr = (pastErr.length == 0) ? 0.0D : err - pastErr[pastErr.length - 1];
    			rot = -(KP * err + KI * ierr + KD * derr);
    			double[] nperr = new double[pastErr.length + 1];
    			System.arraycopy(pastErr, 0, nperr, 0, pastErr.length);
    			nperr[pastErr.length] = err;
    			pastErr = nperr;
    		}
    	} else if(usePID && (((new Date()).getTime() - lastRot.getTime()) > COOLDOWN_TIME) 
    			&& (rot == 0.0D) && ((y != 0.0D) || (x != 0.0D))) {
    		gyro.reset();
    		pastErr = new double[0];
    		isPIDEnabled = true;
    	} else if(rot != 0.0D) {
    		lastRot = new Date();
    	}
		robotDrive.mecanumDrive_Cartesian(x, y, rot, 0);
	}

	public void initDefaultCommand() {
		try {
            setDefaultCommand(_default.newInstance());
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
	}

	@Override
	public void test() {
		
		try {
			// move foraward
			
			if(interationNumber < TEST_DUR) {
				moveCartesian(0.0D, TEST_SPEED, 0.0D, true);
			} else if (interationNumber < TEST_DUR * 2) {
				moveCartesian(0.0D, -TEST_SPEED, 0.0D, true);
			} else if (interationNumber < TEST_DUR * 3) {
				moveCartesian(-TEST_SPEED, 0.0D, 0.0D, true);
			} else if (interationNumber < TEST_DUR * 4) {
				moveCartesian(TEST_SPEED, 0.0D, 0.0D, true);
			} else if (interationNumber < TEST_DUR * 5) {
				moveCartesian(0.0D, 0.0D, TEST_SPEED, true);
			} else if (interationNumber < TEST_DUR * 6) {
				moveCartesian(0.0D, 0.0D, -TEST_SPEED, true);
			} else {
				moveCartesian(0.0D, 0.0D, 0.0D, true);
			}
			interationNumber++;
		
		} catch(final Throwable t) {
			System.err.println("DRIVE TEST FAILURE\n" + t.getClass().toString() + ": " + t.getMessage()
					+ "thrown while running Drive.test()");
		}
	}

	@Override
	public void reset() {
		interationNumber = 0;
		moveCartesian(0.0D, 0.0D, 0.0D, false);
	}
	
	@Override
	public String getName() {
		return "Drive Test";
	}
}
